---
title: 初级数论
date: 2022-10-24 09:10:49
tags: [数论, 同余]
categories: 数学
keywords: 数论, 同余方程, 模, 取模, 扩展欧几里得算法, 扩欧
description: 一点点数论，比较杂
lastmod: 2023-03-02 17:38:29
image: https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg
---

## 质数相关

质数即一个数的因数只包含 $1$ 和自己。  
筛法请见：[[数学/数论基础]]


## 模运算相关

首先，存在唯一的整数 $q,r$ 满足 $n=qm+r, 0\leqslant r<m$，$q$ 就是商，$r$ 就是余数。    
C++ 中模运算可能结果是负数。当 $n<0$ 时，模运算结果满足 $-m<r \leqslant 0$。    
因此可以使用 

```C++
(n % m + m) % m
```

进行取余操作。

## 求[[数学/最大公约数]]


```C++
#include <iostream>
using namespace std;
int main() {
    int a,b,r;
    cin >> a >> b;
    while (a % b) {
        r = a % b;
        a = b;
        b = r;
    }
    cout << b << endl;
    return 0;
}
```

## 同余

### 定义

$a\bmod m = b \bmod m$ 则称 $a,b$ 对于模 $m$ 同余，记为 $a \equiv b \pmod m$

等价于 $m$ 整除 $(a-b)$，即 $m\mid(a-b)$

### 同余方程

$ax \equiv b \pmod m$

已知 $a,b,n$，求解 $x$。  
当且仅当 $b$ 能被 $a$ 和 $n$ 的最大公约数整除时此方程有解  
若 $x_0$ 是方程的一个解，解集即为 $\{ x_0+km /\gcd(a,m) | k\in \mathbf{Z} \}$  

有解证明：

对于线性同余方程 $ax \equiv b\pmod m$ 可以转换为 $ax+km=b,k\in \mathbf{Z}$

设 $d=\gcd(a,m)$，若方程有解为 $c$， 则 $m \mid (ac-b)$ ，从而 $d\mid(ac-b)$，又因为 $d\mid a$，即 $d\mid ac$，于是有 $d\mid b$，即 $\gcd(a,m)\mid b$

### 扩展欧几里得算法

#### 前置知识

##### 裴蜀定理

$$
\forall a,b, \exists x,y,ax+by=\gcd(a,b) 
$$

即 $ax\equiv \gcd(a,b)\pmod b$

#### 用途

* 求解同余方程 $ax \equiv \gcd(a,n) \pmod n$
  * $\forall a,b,\exists x,y,ax+by=\gcd(a,b)$ (裴蜀定理)  
    即 $ax\equiv \gcd(a,b) \pmod b$。而 $x,y$ 可以用扩展欧几里得算法求出

#### 原理

对于方程 $ax_1+by_1=\gcd (a,b)$，由裴蜀定理可得一定存在一组 $x_1,y_1$ 使得等式成立

于是分两类讨论

* $b = 0$ 时，$ax_1+by_1=a$，显然 $x_1 = 1, y_1 \in \mathbf R$

* $b \neq 0$ 时，利用四个未知量 $x_1,y_1,x_2,y_2$ 列出两个方程 
  
  $$
  \begin{cases}
ax_1+by_1 = \gcd(a,b) = \gcd(b, a\bmod b) ① \\\\
bx_2+(a\bmod b)y_2 = \gcd(b, a \bmod b) = \gcd(a,b) = ax_1+by_1 ②
\end{cases}
  $$
  
  易得
  
  $$
  a \bmod b = a-\lfloor\frac{a}{b}\rfloor b
  $$
  
  由此我们可以继续展开推导 $②$ 式
  
  $$
\begin{aligned}
bx_2+(a\bmod b)y_2 &= ax_1+by_1 \\
bx_2+(a-\lfloor \dfrac{a}{b}\rfloor b)y_2 &= ax_1+by_1 \\
ay_2+b(x_2-\lfloor \dfrac{a}{b} \rfloor y_2) &= ax_1+by_1
\end{aligned}
  $$
  
  <!--$x_2,y_2$ 只是两个表示未知量的符号，所以我们可以把它们两个互换一下，得到
  
  $$
  ax_2+b(y_2-\lfloor \dfrac{a}{b} \rfloor x_2) = ax_1+by_1
  $$
  -->
  
  因此
  
  $$
\begin{cases}
x_1 = y_2 \\
y_1 = x_2-\lfloor \dfrac{a}{b} \rfloor y_2
\end{cases}
  $$

#### 实现

%%* 算法：函数 `ex_gcd(a,b)`
  * 若 $b=0$，$ax_1+by_1=\gcd(a,b)$ 的解是 $x_1=1,y_1=0$，直接返回
  * 否则递归调用 $\operatorname{ex\_gcd}(b,a\bmod b)$，求解 $bx_2+(a\bmod b)y_2 = \gcd(b, a\bmod b)$
  * 用上一步解的 $x_2,y_2$，令 $x_1=y_2, y_1=x_2-\lfloor \dfrac{a}{b} \rfloor y_2$ ，$x_1$ 和 $y_1$ 就是当前方程的解
  * 返回 $x_1,y_1$
* 对于任意同余方程 $ax\equiv b \pmod n$，只要满足 $\gcd(a,n)\mid b$  
  就可以先用扩欧求出 $ax_2\equiv \gcd(a,n)\ \pmod n$  
  即 $d=\gcd(a,n)$，得到 $a(\frac bd)x_2\equiv b\ \pmod n$  
  所以原方程一解 $x_0=(\frac bd)x_2$，通解 $x_0+(\frac nd)k, k\in \mathbf{Z}$%%  

##### 运算符 $\operatorname{exgcd}(a,b,x,y)$

采用递归实现，因此先判定递归边界，则 $b=0$ 时到达边界，此时 $x = 1, y = 0$

未到边界，则先继续调用 $\operatorname{exgcd}(b, a\bmod b, x, y)$ ，然后根据递归回溯得到的 $x,y$ 得到 $x_1, y_1$，即
$$
\begin{cases}
x_1 = y \\
y_1 = x-\lfloor \dfrac{a}{b} \rfloor y
\end{cases}
$$
返回到头为止。

##### 求解 $ax + by = c$ ，即 $a \equiv c \pmod b$

先判断是否有解，若 $\gcd(a,b) \mid c$ 则有解（[[#裴蜀定理]]）
然后利用 $\operatorname{exgcd}$ 求解 $ax_1 + by_1 = \gcd (a,b)$
即得到一份特解 $x = x_1 \times \frac{c}{\gcd(a,b)}, y = y_1 \times \frac{c}{\gcd(a,b)}$ 

求通解，实质上是使 $x,y$ 进行一定变换但等式依然成立。
易想到 $x$ 下降时 $y$ 上升，因此设：$g = \gcd(a,b), i>j$
$$
\begin{aligned}
ax_i+by_i&=c \\
ax_j + by_j &= c
\end{aligned} \\
$$
导一下式子，得
$$
\begin{aligned}
ax_i+by_i &= ax_j + by_j \\
a(x_i - x_j) &= b(y_j - y_i) \\
\frac ag (x_i - x_j) &= \frac bg (y_j - y_i)
\end{aligned} \\
$$
因为 $g$ 是最大公因数，所以 $\frac ag$ 与 $\frac bg$ 互质。又因为方程中每一个字母都是整数，所以易得：$\frac bg$ 是 $x_i-x_j$ 的倍数，而 $\frac ag$ 是 $y_j - y_i$ 的倍数（即 $- \frac ag$ 是 $y_i - y_j$ 的倍数）

于是通解就推出来了
$$
\begin{cases}
\mathbf X = \{x+\cfrac bg k \mid k\in\mathbf Z\} \\
\mathbf Y = \{y-\cfrac ag k \mid k\in\mathbf Z\}
\end{cases}
$$



#### 代码

```cpp
int ex_gcd(int a, int b, int &x, int &y) {
    if (!v) {
        x = 1, y = 0;
        return a;
    }

    int xx, yy;
    int g = ex_gcd(b, a % b, xx, yy);
    x = yy;
    y = xx - u / v * yy;
    return g; 
}
```