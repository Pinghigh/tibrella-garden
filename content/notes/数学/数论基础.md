---
title: 初级数论
date: 2022-10-24 09:10:49
tags: [数论, 同余]
categories: 数学
keywords: 数论, 同余方程, 模, 取模, 扩展欧几里得算法, 扩欧
description: 一点点数论，比较杂
lastmod: 2023-03-02 17:38:29
image: https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg
---

## 质数相关

质数即一个数的因数只包含 $1$ 和自己。  
筛法请见：[[数学/数论基础]]


## 模运算相关

首先，存在唯一的整数 $q,r$ 满足 $n=qm+r, 0\leqslant r<m$，$q$ 就是商，$r$ 就是余数。    
C++ 中模运算可能结果是负数。当 $n<0$ 时，模运算结果满足 $-m<r \leqslant 0$。    
因此可以使用 

```C++
((n%m)+m)%m
```

进行取余操作。

## 求[[数学/最大公约数]]


```C++
#include <iostream>
using namespace std;
int main() {
    int a,b,r;
    cin >> a >> b;
    while (a % b) {
        r = a % b;
        a = b;
        b = r;
    }
    cout << b << endl;
    return 0;
}
```

## 同余

### 定义

$a\bmod m = b \bmod m$ 则称 $a,b$ 对于模 $m$ 同余，记为 $a \equiv b \pmod m$

等价于 $m$ 整除 $(a-b)$，即 $m\mid(a-b)$

### 同余方程

$ax \equiv b \pmod m$

已知 $a,b,n$，求解 $x$。  
当且仅当 $b$ 能被 $a$ 和 $n$ 的最大公约数整除时此方程有解  
若 $x_0$ 是方程的一个解，解集即为 $\{ x_0+km /\gcd(a,m) | k\in \mathbf{Z} \}$  

有解证明：

对于线性同余方程 $ax \equiv b\pmod m$ 可以转换为 $ax+km=b,k\in \mathbf{Z}$

设 $d=\gcd(a,m)$，若方程有解为 $c$， 则 $m \mid (ac-b)$ ，从而 $d\mid(ac-b)$，又因为 $d\mid a$，即 $d\mid ac$，于是有 $d\mid b$，即 $\gcd(a,m)\mid b$

### 扩展欧几里得算法

#### 前置知识

##### 裴蜀定理

$$
\forall a,b, \exists x,y,ax+by=\gcd(a,b) 
$$

即 $ax\equiv \gcd(a,b)\pmod b$

#### 用途

* 求解同余方程 $ax \equiv \gcd(a,n) \pmod n$
  * $\forall a,b,\exists x,y,ax+by=\gcd(a,b)$ (裴蜀定理)  
    即 $ax\equiv \gcd(a,b) \pmod b$。而 $x,y$ 可以用扩展欧几里得算法求出

#### 原理

对于方程 $ax_1+by_1=\gcd (a,b)$，由裴蜀定理可得一定存在一组 $x_1,y_1$ 使得等式成立

于是分两类讨论

* $b = 0$ 时，$ax_1+by_1=a$，显然 $x_1 = 1, y_1 \in \mathbf R$

* $b \neq 0$ 时，利用四个未知量 $x_1,y_1,x_2,y_2$ 列出两个方程 
  
  $$
  \begin{cases}
ax_1+by_1 = \gcd(a,b) = \gcd(b, a\bmod b) ① \\\\
bx_2+(a\bmod b)y_2 = \gcd(b, a \bmod b) = \gcd(a,b) = ax_1+by_1 ②
\end{cases}
  $$
  
  易得
  
  $$
  a \bmod b = a-\lfloor\frac{a}{b}\rfloor b
  $$
  
  由此我们可以继续展开推导 $②$ 式
  
  $$
\begin{aligned}
bx_2+(a\bmod b)y_2 &= ax_1+by_1 \\\\
bx_2+(a-\lfloor \dfrac{a}{b}\rfloor b)y_2 &= ax_1+by_1 \\\\
ay_2+b(x_2-\lfloor \dfrac{a}{b} \rfloor y_2) &= ax_1+by_1
\end{aligned}
  $$
  
  <!--$x_2,y_2$ 只是两个表示未知量的符号，所以我们可以把它们两个互换一下，得到
  
  $$
  ax_2+b(y_2-\lfloor \dfrac{a}{b} \rfloor x_2) = ax_1+by_1
  $$
  -->
  
  因此
  
  $$
  \begin{cases}
x_1 = y_2 \\\\
y_1 = x_2-\lfloor \dfrac{a}{b} \rfloor y_2
\end{cases}
  $$

#### 实现

* 算法：函数 `ex_gcd(a,b)`
  * 若 $b=0$，$ax_1+by_1=\gcd(a,b)$ 的解是 $x_1=1,y_1=0$，直接返回
  * 否则递归调用 $\operatorname{ex\_gcd}(b,a\bmod b)$，求解 $bx_2+(a\bmod b)y_2 = \gcd(b, a\bmod b)$
  * 用上一步解的 $x_2,y_2$，令 $x_1=y_2, y_1=x_2-\lfloor \dfrac{a}{b} \rfloor y_2$ ，$x_1$ 和 $y_1$ 就是当前方程的解
  * 返回 $x_1,y_1$
* 对于任意同余方程 $ax\equiv b \pmod n$，只要满足 $\gcd(a,n)\mid b$  
  就可以先用扩欧求出 $ax_2\equiv \gcd(a,n)\ \pmod n$  
  即 $d=\gcd(a,n)$，得到 $a(\frac bd)x_2\equiv b\ \pmod n$  
  所以原方程一解 $x_0=(\frac bd)x_2$，通解 $x_0+(\frac nd)k, k\in \mathbf{Z}$  

#### 代码

```cpp
int ex_gcd(int a, int b, int &x, int &y) {
    if (!v) {
        x = 1, y = 0;
        return a;
    }

    int xx, yy;
    int g = ex_gcd(b, a % b, xx, yy);
    x = yy;
    y = xx - u / v * yy;
    return g; 
}
```